{
    "Basic Code": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "#pragma GCC optimize(2)",
            "#define endl \"\\n\"",
            "#define ll long long",
            "#define mm(a) memset(a,0,sizeof(a))",
            "using namespace std;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    ",
            "    $0",
            "",
            "    return 0;",
            "}"
        ],
        "description": "Cpp basic code template"
    },
    "Common Include": {
        "prefix": "include",
        "body": [
            "#include <cstdio>",
            "#include <cstring>",
            "#include <algorithm>",
            "#include <iostream>",
            "#include <string>",
            "#include <vector>",
            "#include <stack>",
            "#include <cstdlib>",
            "#include <cmath>",
            "#include <set>",
            "#include <list>",
            "#include <map>"
        ],
        "description": "Common header files"
    },
    "POJ Only": {
        "prefix": "poj",
        "body": [
            "#include <algorithm>",
            "#include <cmath>",
            "#include <cstdio>",
            "#include <cstdlib>",
            "#include <cstring>",
            "#include <iostream>",
            "#include <list>",
            "#include <map>",
            "#include <set>",
            "#include <stack>",
            "#include <string>",
            "#include <vector>",
            "$2",
            "int main() {",
            "    $1$0",
            "    return 0;",
            "}"
        ],
        "description": "Baisc cpp code for POJ and other oj without std/bitsc++.h"
    },
    "Euler's Sieve with Vector": {
        "prefix": "ola_vector",
        "body": [
          "const int ola_maxn = ${1:1e6 + 10};",
          "bool ola_ispri[ola_maxn];",
          "vector<int> ola_pri;",
          "inline void ola() {",
          "    memset(ola_ispri,true,sizeof(ola_ispri));",
          "    ola_ispri[0] = ola_ispri[1] = false;",
          "    for (int i = 2; i < ola_maxn; i++) {",
          "        if (ola_ispri[i])",
          "            ola_pri.push_back(i);",
          "        for (auto j : ola_pri) {",
          "            if (i * j >= ola_maxn)",
          "                break;",
          "            ola_ispri[i * j] = false;",
          "            if (i % j == 0)",
          "                break;",
          "        }",
          "    }",
          "}$0"
        ],
        "description": "Euler's Sieve with Vector"
      },
      "Euler's Sieve with Arry": {
        "prefix": "ola",
        "body": [
          "const int ola_maxn = ${1:1e6 + 10};",
          "bool ola_ispri[ola_maxn];",
          "int ola_pri[ola_maxn], ola_n = 0;",
          "inline void ola() {",
          "    memset(ola_ispri, true, sizeof(ola_ispri));",
          "    ola_ispri[0] = ola_ispri[1] = false;",
          "    for (int i = 2; i < ola_maxn; i++) {",
          "        if (ola_ispri[i])",
          "            ola_pri[ola_n++] = i;",
          "        for (int j = 0; j < ola_n; j++) {",
          "            if (i * ola_pri[j] >= ola_maxn)",
          "                break;",
          "            ola_ispri[i * ola_pri[j]] = false;",
          "            if (i % ola_pri[j] == 0)",
          "                break;",
          "        }",
          "    }",
          "}$0"
        ],
        "description": "Euler's Sieve with Arry"
      },
      "T times while": {
        "prefix": "T",
        "body": [
          "int ${1:T};",
          "cin>>${1:T};",
          "while(${1:T}--){",
          "    $0",
          "}"
        ],
        "description": "T times while"
      },
      "KMP": {
        "prefix": "kmp",
        "body": [
          "class KMP {",
          "private:",
          "    string pat;",
          "    int *next;",
          "public:",
          "    void pattern(string _pat){",
          "        pat = _pat;",
          "        next = new int[pat.length()];",
          "        next[0] = 0;",
          "        for (int i = 1, j = 0; i < pat.length(); i++) {",
          "            while (j > 0 && pat[i] != pat[j])",
          "                j = next[j - 1];",
          "            if (pat[i] == pat[j])",
          "                j++;",
          "            next[i] = j;",
          "        }",
          "    }",
          "    KMP(string _pat=\"\") {",
          "        delete[] next;",
          "        pattern(_pat);",
          "    }    ",
          "    int find(string text) {",
          "        for (int i = 0, j = 0; i < text.length(); i++) {",
          "            while (j > 0 && text[i] != pat[j])",
          "                j = next[j - 1];",
          "            if (text[i] == pat[j])",
          "                j++;",
          "            if (j == pat.length())",
          "                return i - j + 1;",
          "        }",
          "        return -1;",
          "    }",
          "    vector<int> count(string text) {",
          "        vector<int>ans;",
          "        for (int i = 0, j = 0; i < text.length(); i++) {",
          "            while (j > 0 && text[i] != pat[j])",
          "                j = next[j - 1];",
          "            if (text[i] == pat[j])",
          "                j++;",
          "            if (j == pat.length())",
          "                ans.push_back(i - j + 1);",
          "        }",
          "        return ans;",
          "    }",
          "    ~KMP() { delete[] next; }",
          "};"
        ],
        "description": "KMP"
      },
}